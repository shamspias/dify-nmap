import logging
import re
from collections.abc import Generator
from typing import Any, List, Dict, Optional
from collections import defaultdict
import time
from urllib.parse import urlparse

from dify_plugin import Tool
from dify_plugin.entities.tool import ToolInvokeMessage
from pydantic import BaseModel, Field, validator

logger = logging.getLogger(__name__)


class VulnerabilityScannerParameters(BaseModel):
    """Enhanced vulnerability scanning parameters"""

    target: str = Field(
        ...,
        description="Target to scan (IP, domain, or URL)"
    )

    scan_strategy: str = Field(
        "comprehensive",
        description="Scan strategy: quick, smart, comprehensive, deep, custom"
    )

    vuln_categories: List[str] = Field(
        default_factory=lambda: ["all"],
        description="Categories: web, ssl, smb, database, mail, dns, all"
    )

    port_range: str = Field(
        "auto",
        description="Ports: auto, common, top100, top1000, all, or specific (80,443)"
    )

    # CVE and exploit checks
    check_cves: bool = Field(
        True,
        description="Check for known CVEs"
    )

    exploit_db_check: bool = Field(
        True,
        description="Check against exploit database"
    )

    cve_year_filter: Optional[int] = Field(
        None,
        description="Only check CVEs from this year onwards"
    )

    # Performance settings
    parallel_scripts: int = Field(
        5,
        ge=1,
        le=20,
        description="Number of scripts to run in parallel"
    )

    script_timeout: str = Field(
        "30s",
        description="Timeout per script"
    )

    aggressive_mode: bool = Field(
        False,
        description="Use aggressive/intrusive scripts"
    )

    # Detection options
    detect_waf: bool = Field(
        True,
        description="Detect Web Application Firewalls"
    )

    version_detection: bool = Field(
        True,
        description="Detailed version detection"
    )

    @validator('target')
    def clean_target(cls, v):
        """Clean and validate target"""
        # Remove protocol if present
        if v.startswith(('http://', 'https://')):
            parsed = urlparse(v)
            v = parsed.hostname or parsed.netloc
        # Remove trailing slashes and paths
        v = v.split('/')[0]
        # Remove port if specified separately
        v = v.split(':')[0]
        return v


class VulnerabilityScanner(Tool):
    """Fixed high-performance vulnerability scanner with CVE detection"""

    # Correct NSE script names organized by category and speed
    VULNERABILITY_SCRIPTS = {
        "web": {
            "detection": [
                "http-vuln-*",  # All HTTP vulnerability scripts
                "http-sql-injection",
                "http-stored-xss",
                "http-dombased-xss",
                "http-phpself-xss",
                "http-csrf",
                "http-shellshock",
                "http-slowloris-check",
                "http-enum",
                "http-methods",
                "http-trace",
                "http-internal-ip-disclosure",
                "http-errors",
                "http-git",
                "http-svn-info",
                "http-backup-finder",
                "http-config-backup",
                "http-default-accounts",
                "http-passwd",
                "http-php-version",
                "http-webdav-scan",
                "http-iis-webdav-vuln",
                "http-aspnet-debug",
                "http-frontpage-login",
                "http-adobe-coldfusion-apsa1301",
                "http-coldfusion-subzero",
                "http-vuln-cve2006-3392",  # Webmin
                "http-vuln-cve2009-3960",  # Adobe
                "http-vuln-cve2010-0738",  # JBoss
                "http-vuln-cve2010-2861",  # ColdFusion
                "http-vuln-cve2011-3192",  # Apache
                "http-vuln-cve2011-3368",  # Apache
                "http-vuln-cve2012-1823",  # PHP-CGI
                "http-vuln-cve2013-0156",  # Rails
                "http-vuln-cve2013-6786",  # Allegro
                "http-vuln-cve2013-7091",  # Zimbra
                "http-vuln-cve2014-2126",  # Cisco
                "http-vuln-cve2014-2127",  # Cisco
                "http-vuln-cve2014-2128",  # Cisco
                "http-vuln-cve2014-2129",  # Cisco
                "http-vuln-cve2014-3704",  # Drupal
                "http-vuln-cve2014-8877",  # Wordpress
                "http-vuln-cve2015-1427",  # Elasticsearch
                "http-vuln-cve2015-1635",  # IIS
                "http-vuln-cve2017-1001000",  # Wordpress
                "http-vuln-cve2017-5638",  # Struts
                "http-vuln-cve2017-5689",  # Intel AMT
                "http-vuln-cve2017-8917",  # Joomla
            ],
            "waf": [
                "http-waf-detect",
                "http-waf-fingerprint"
            ]
        },
        "ssl": {
            "detection": [
                "ssl-*",  # All SSL scripts
                "ssl-heartbleed",
                "ssl-poodle",
                "ssl-ccs-injection",
                "ssl-cert",
                "ssl-date",
                "ssl-enum-ciphers",
                "ssl-known-key",
                "sslv2",
                "ssl-dh-params",
                "tls-ticketbleed",
                "tls-nextprotoneg",
                "tls-alpn"
            ]
        },
        "smb": {
            "detection": [
                "smb-vuln-*",  # All SMB vulnerability scripts
                "smb-vuln-conficker",
                "smb-vuln-cve2009-3103",
                "smb-vuln-cve-2017-7494",
                "smb-vuln-ms06-025",
                "smb-vuln-ms07-029",
                "smb-vuln-ms08-067",
                "smb-vuln-ms10-054",
                "smb-vuln-ms10-061",
                "smb-vuln-ms17-010",  # EternalBlue
                "smb-vuln-regsvc-dos",
                "smb-vuln-webexec",
                "smb-double-pulsar-backdoor",
                "smb-os-discovery",
                "smb-protocols",
                "smb-security-mode",
                "smb2-security-mode",
                "smb2-capabilities",
                "smb2-vuln-uptime"
            ]
        },
        "database": {
            "detection": [
                "mysql-vuln-*",
                "mysql-empty-password",
                "mysql-users",
                "mysql-databases",
                "mysql-variables",
                "mysql-audit",
                "mysql-dump-hashes",
                "ms-sql-*",
                "ms-sql-empty-password",
                "ms-sql-xp-cmdshell",
                "ms-sql-config",
                "ms-sql-dump-hashes",
                "mongodb-databases",
                "mongodb-info",
                "redis-info",
                "cassandra-info",
                "couchdb-databases",
                "oracle-sid-brute",
                "oracle-brute",
                "pgsql-brute"
            ]
        },
        "mail": {
            "detection": [
                "smtp-vuln-*",
                "smtp-commands",
                "smtp-enum-users",
                "smtp-open-relay",
                "smtp-strangeport",
                "smtp-ntlm-info",
                "imap-capabilities",
                "imap-ntlm-info",
                "pop3-capabilities",
                "pop3-ntlm-info"
            ]
        },
        "dns": {
            "detection": [
                "dns-*",
                "dns-zone-transfer",
                "dns-cache-snoop",
                "dns-recursion",
                "dns-service-discovery",
                "dns-nsec-enum",
                "dns-nsec3-enum",
                "dns-srv-enum",
                "dns-random-srcport",
                "dns-random-txid"
            ]
        },
        "ftp": {
            "detection": [
                "ftp-*",
                "ftp-anon",
                "ftp-bounce",
                "ftp-libopie",
                "ftp-proftpd-backdoor",
                "ftp-vsftpd-backdoor",
                "ftp-vuln-cve2010-4221"
            ]
        },
        "ssh": {
            "detection": [
                "ssh-*",
                "ssh-hostkey",
                "ssh-auth-methods",
                "ssh2-enum-algos",
                "ssh-run",
                "sshv1"
            ]
        },
        "cve": {
            "detection": [
                "vulners",  # Main CVE detection script
                "vulscan",  # Alternative CVE scanner
                "nmap-vulners"  # Another CVE database
            ]
        },
        "default": {
            "detection": [
                "default",  # Default safe scripts
                "discovery",  # Discovery scripts
                "version",  # Version detection
                "safe"  # Safe scripts
            ]
        },
        "auth": {
            "detection": [
                "auth",  # Authentication scripts
                "http-auth",
                "http-auth-finder",
                "http-default-accounts",
                "ssh-auth-methods",
                "ftp-anon",
                "mysql-empty-password",
                "ms-sql-empty-password",
                "vnc-auth",
                "snmp-brute"
            ]
        }
    }

    # Common ports by service type
    PORT_MAPPINGS = {
        "web": "80,443,8080,8443,8000,8888,9090,3000,4443",
        "ssl": "443,8443,993,995,636,3389,5900",
        "smb": "139,445",
        "database": "1433,1521,3306,5432,5984,6379,7000,7001,8086,9042,9200,27017",
        "mail": "25,110,143,465,587,993,995",
        "dns": "53",
        "ftp": "21,990",
        "ssh": "22,2222",
        "common": "21,22,23,25,53,80,110,139,143,443,445,993,995,1433,3306,3389,5432,8080,8443",
        "top100": "--top-ports 100",
        "top1000": "--top-ports 1000",
        "all": "-p-"
    }

    def _build_scan_arguments(self, params: VulnerabilityScannerParameters) -> tuple[str, List[str]]:
        """Build optimized Nmap arguments for vulnerability scanning"""
        args = []
        scripts_to_run = []

        # Determine ports to scan
        if params.port_range == "auto":
            # Auto-detect based on categories
            ports = set()
            for category in params.vuln_categories:
                if category in self.PORT_MAPPINGS:
                    ports.update(self.PORT_MAPPINGS[category].split(','))
                elif category == "all":
                    ports = [self.PORT_MAPPINGS["common"]]
                    break

            if ports and not any("--top-ports" in p for p in ports):
                args.append(f"-p {','.join(sorted(ports, key=lambda x: int(x) if x.isdigit() else 0))}")
            elif ports:
                args.append(ports[0])
        elif params.port_range in self.PORT_MAPPINGS:
            args.append(self.PORT_MAPPINGS[params.port_range] if "--top-ports" in self.PORT_MAPPINGS[
                params.port_range] else f"-p {self.PORT_MAPPINGS[params.port_range]}")
        else:
            # Custom port range
            args.append(f"-p {params.port_range}")

        # Service and version detection
        if params.version_detection:
            args.append("-sV")
            args.append("--version-intensity 8")
        else:
            args.append("-sV")  # Basic service detection needed for scripts

        # Build script list based on categories
        if "all" in params.vuln_categories:
            # Use all relevant vulnerability scripts
            for category, scripts_dict in self.VULNERABILITY_SCRIPTS.items():
                if category != "default":  # Skip default for 'all'
                    scripts_to_run.extend(scripts_dict.get("detection", []))
                    if "waf" in scripts_dict and params.detect_waf:
                        scripts_to_run.extend(scripts_dict["waf"])
        else:
            # Use specific category scripts
            for category in params.vuln_categories:
                if category in self.VULNERABILITY_SCRIPTS:
                    scripts_dict = self.VULNERABILITY_SCRIPTS[category]
                    scripts_to_run.extend(scripts_dict.get("detection", []))
                    if "waf" in scripts_dict and params.detect_waf:
                        scripts_to_run.extend(scripts_dict["waf"])

        # Add CVE detection scripts if enabled
        if params.check_cves:
            scripts_to_run.extend([
                "vulners",
                "vulscan"
            ])

            # Add CVE year filter if specified
            if params.cve_year_filter:
                args.append(f"--script-args vulners.minyear={params.cve_year_filter}")

        # Add exploit-db check if enabled
        if params.exploit_db_check:
            scripts_to_run.append("exploit")
            scripts_to_run.append("nmap-vulners")

        # Determine scan aggressiveness
        if params.scan_strategy == "quick":
            # Only critical scripts
            scripts_to_run = [s for s in scripts_to_run if
                              'heartbleed' in s or 'ms17-010' in s or 'shellshock' in s or 'poodle' in s]
            args.append("-T4")
        elif params.scan_strategy == "smart":
            # Balanced approach
            args.append("-T3")
        elif params.scan_strategy == "comprehensive":
            # All selected scripts
            args.append("-T3")
        elif params.scan_strategy == "deep":
            # Everything including intrusive
            if params.aggressive_mode:
                scripts_to_run.extend(["intrusive", "exploit", "brute"])
            args.append("-T2")

        # Remove duplicates and filter out invalid patterns
        unique_scripts = []
        seen = set()
        for script in scripts_to_run:
            if script and script not in seen:
                seen.add(script)
                unique_scripts.append(script)

        # Join scripts for Nmap
        if unique_scripts:
            script_string = ",".join(unique_scripts)
            args.append(f"--script={script_string}")

        # Performance settings
        args.append(f"--max-parallelism {params.parallel_scripts}")
        args.append(f"--script-timeout {params.script_timeout}")

        # Additional arguments
        args.append("--max-retries 2")
        args.append("--host-timeout 10m")
        args.append("-Pn")  # Skip ping for web servers

        # Add verbosity for debugging
        args.append("-v")

        return " ".join(args), unique_scripts

    def _parse_vulnerabilities(self, nm, scan_result: dict, scripts_run: List[str]) -> dict:
        """Parse vulnerability findings from scan results"""
        vulns = {
            "summary": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0,
                "total": 0
            },
            "hosts": [],
            "cves": [],
            "exploits": [],
            "scripts_executed": scripts_run,
            "services": {}
        }

        for host in nm.all_hosts():
            host_vulns = {
                "address": host,
                "hostname": nm[host].hostname() if nm[host].hostname() else host,
                "state": nm[host].state(),
                "vulnerabilities": [],
                "services": [],
                "open_ports": []
            }

            # Process each port
            for proto in nm[host].all_protocols():
                for port in nm[host][proto].keys():
                    port_info = nm[host][proto][port]

                    # Track open ports and services
                    if port_info['state'] == 'open':
                        host_vulns['open_ports'].append(port)
                        service_name = port_info.get('name', 'unknown')
                        service_info = {
                            "port": port,
                            "protocol": proto,
                            "service": service_name,
                            "product": port_info.get('product', ''),
                            "version": port_info.get('version', ''),
                            "extrainfo": port_info.get('extrainfo', '')
                        }
                        host_vulns['services'].append(service_info)

                        # Track service types
                        if service_name not in vulns['services']:
                            vulns['services'][service_name] = 0
                        vulns['services'][service_name] += 1

                    # Check for script results
                    if 'script' in port_info:
                        for script_name, script_output in port_info['script'].items():
                            # Parse vulnerability information
                            vuln_info = self._extract_vulnerability_info(
                                script_name,
                                script_output,
                                port,
                                port_info.get('name', 'unknown')
                            )

                            if vuln_info:
                                host_vulns['vulnerabilities'].append(vuln_info)
                                vulns['summary'][vuln_info['severity']] += 1
                                vulns['summary']['total'] += 1

                                # Extract CVEs
                                cves = self._extract_cves(script_output)
                                if cves:
                                    vulns['cves'].extend(cves)
                                    vuln_info['cves'] = cves

                                # Check for exploits
                                if 'exploit' in script_name.lower() or 'EXPLOIT' in script_output:
                                    vulns['exploits'].append({
                                        "port": port,
                                        "script": script_name,
                                        "description": script_output[:200]
                                    })

            # Check host-level scripts
            if 'hostscript' in nm[host]:
                for script in nm[host]['hostscript']:
                    vuln_info = self._extract_vulnerability_info(
                        script['id'],
                        script.get('output', ''),
                        'host',
                        'host'
                    )

                    if vuln_info:
                        host_vulns['vulnerabilities'].append(vuln_info)
                        vulns['summary'][vuln_info['severity']] += 1
                        vulns['summary']['total'] += 1

                        # Extract CVEs
                        cves = self._extract_cves(script.get('output', ''))
                        if cves:
                            vulns['cves'].extend(cves)
                            vuln_info['cves'] = cves

            # Add host to results if it has findings or open ports
            if host_vulns['vulnerabilities'] or host_vulns['open_ports']:
                vulns['hosts'].append(host_vulns)

        # Remove duplicate CVEs
        vulns['cves'] = list(set(vulns['cves']))

        return vulns

    def _extract_vulnerability_info(self, script_name: str, output: str, port: Any, service: str) -> Optional[Dict]:
        """Extract structured vulnerability information from script output"""

        # Skip non-vulnerability scripts
        if not any(keyword in script_name.lower() or keyword in output.lower()
                   for keyword in ['vuln', 'cve', 'exploit', 'vulnerable', 'risk', 'threat',
                                   'attack', 'injection', 'overflow', 'disclosure']):
            return None

        vuln_info = {
            "port": port,
            "service": service,
            "script": script_name,
            "title": self._get_vuln_title(script_name, output),
            "severity": self._determine_severity(script_name, output),
            "description": self._clean_output(output)[:500],
            "remediation": self._get_remediation(script_name, output),
            "references": self._extract_references(output)
        }

        return vuln_info

    def _get_vuln_title(self, script_name: str, output: str) -> str:
        """Generate a readable vulnerability title"""

        # Common vulnerability patterns
        titles = {
            "ssl-heartbleed": "Heartbleed SSL Vulnerability",
            "ssl-poodle": "POODLE SSL Vulnerability",
            "ssl-ccs-injection": "SSL CCS Injection Vulnerability",
            "ms17-010": "EternalBlue SMB Vulnerability (MS17-010)",
            "http-shellshock": "Shellshock Bash Vulnerability",
            "http-sql-injection": "SQL Injection Vulnerability",
            "http-stored-xss": "Stored Cross-Site Scripting (XSS)",
            "http-csrf": "Cross-Site Request Forgery (CSRF)",
            "smb-vuln-conficker": "Conficker Worm Vulnerability",
            "mysql-empty-password": "MySQL Empty Password",
            "ftp-anon": "Anonymous FTP Access",
            "smtp-open-relay": "Open Mail Relay"
        }

        # Check for known titles
        for key, title in titles.items():
            if key in script_name.lower():
                return title

        # Extract CVE if present
        cve_match = re.search(r'CVE-\d{4}-\d+', output, re.IGNORECASE)
        if cve_match:
            return f"Vulnerability {cve_match.group()}"

        # Clean up script name for title
        title = script_name.replace('-', ' ').replace('_', ' ')
        title = ' '.join(word.capitalize() for word in title.split())
        return f"{title} Detected"

    def _determine_severity(self, script_name: str, output: str) -> str:
        """Determine vulnerability severity based on script and output"""

        output_lower = output.lower()
        script_lower = script_name.lower()

        # Critical severity indicators
        critical_indicators = [
            'critical', 'rce', 'remote code execution', 'remote command',
            'arbitrary code', 'heartbleed', 'shellshock', 'ms17-010',
            'eternalblue', 'wannacry', 'petya', 'conficker',
            'score: 10', 'cvss: 10', 'cvss:3.1/av:n/ac:l/pr:n/ui:n'
        ]

        # High severity indicators
        high_indicators = [
            'high', 'sql injection', 'authentication bypass', 'privilege escalation',
            'arbitrary file', 'directory traversal', 'xxe', 'deserialization',
            'score: 9', 'score: 8', 'score: 7', 'cvss: 9', 'cvss: 8', 'cvss: 7',
            'empty password', 'default credentials', 'no authentication'
        ]

        # Medium severity indicators
        medium_indicators = [
            'medium', 'xss', 'cross-site', 'csrf', 'clickjacking', 'open redirect',
            'information disclosure', 'session', 'cookie', 'weak',
            'score: 6', 'score: 5', 'score: 4', 'cvss: 6', 'cvss: 5', 'cvss: 4'
        ]

        # Low severity indicators
        low_indicators = [
            'low', 'minor', 'informational', 'verbose', 'banner', 'version',
            'score: 3', 'score: 2', 'score: 1', 'cvss: 3', 'cvss: 2', 'cvss: 1'
        ]

        # Check for severity indicators
        for indicator in critical_indicators:
            if indicator in output_lower or indicator in script_lower:
                return 'critical'

        for indicator in high_indicators:
            if indicator in output_lower or indicator in script_lower:
                return 'high'

        for indicator in medium_indicators:
            if indicator in output_lower or indicator in script_lower:
                return 'medium'

        for indicator in low_indicators:
            if indicator in output_lower or indicator in script_lower:
                return 'low'

        # Default to info if no clear severity
        return 'info'

    def _clean_output(self, output: str) -> str:
        """Clean and format script output for readability"""
        # Remove excessive whitespace
        output = re.sub(r'\s+', ' ', output)
        # Remove ANSI codes if present
        output = re.sub(r'\x1b\[[0-9;]*m', '', output)
        # Trim
        return output.strip()

    def _get_remediation(self, script_name: str, output: str) -> str:
        """Provide remediation suggestions based on vulnerability"""

        remediations = {
            "ssl-heartbleed": "Update OpenSSL to version 1.0.1g or later",
            "ssl-poodle": "Disable SSLv3 protocol support",
            "ms17-010": "Apply Microsoft security update MS17-010",
            "http-shellshock": "Update Bash to a patched version",
            "http-sql-injection": "Implement input validation and use parameterized queries",
            "http-stored-xss": "Implement output encoding and input validation",
            "mysql-empty-password": "Set a strong password for MySQL root user",
            "ftp-anon": "Disable anonymous FTP access",
            "smtp-open-relay": "Configure mail server to prevent relaying"
        }

        for key, remediation in remediations.items():
            if key in script_name.lower():
                return remediation

        # Generic remediation based on severity
        if 'critical' in self._determine_severity(script_name, output):
            return "Apply vendor security patches immediately"
        elif 'high' in self._determine_severity(script_name, output):
            return "Apply security updates as soon as possible"
        else:
            return "Review and apply recommended security configurations"

    def _extract_references(self, output: str) -> List[str]:
        """Extract reference URLs and CVE numbers from output"""
        references = []

        # Extract CVEs
        cves = re.findall(r'CVE-\d{4}-\d+', output, re.IGNORECASE)
        references.extend(cves)

        # Extract URLs
        urls = re.findall(r'https?://[^\s<>"{}|\\^`\[\]]+', output)
        references.extend(urls[:3])  # Limit to 3 URLs

        # Extract CWE numbers
        cwes = re.findall(r'CWE-\d+', output, re.IGNORECASE)
        references.extend(cwes)

        return list(set(references))[:5]  # Return unique, limited to 5

    def _extract_cves(self, text: str) -> List[str]:
        """Extract CVE identifiers from text"""
        cves = re.findall(r'CVE-\d{4}-\d+', text, re.IGNORECASE)
        return list(set(cves))

    def _format_report(self, vulns: dict, params: VulnerabilityScannerParameters) -> str:
        """Create a detailed vulnerability report"""
        output = []

        # Header
        output.append("â•”" + "â•" * 78 + "â•—")
        output.append("â•‘" + " " * 20 + "ğŸ›¡ï¸ VULNERABILITY SCAN REPORT" + " " * 21 + "â•‘")
        output.append("â• " + "â•" * 78 + "â•£")

        # Target and scan info
        output.append(f"â•‘ ğŸ¯ Target: {params.target}" + " " * (64 - len(params.target[:50])) + "â•‘")
        output.append(f"â•‘ ğŸ“‹ Strategy: {params.scan_strategy.upper()}" + " " * (62 - len(params.scan_strategy)) + "â•‘")
        output.append(f"â•‘ ğŸ” Scripts Executed: {len(vulns['scripts_executed'])}" + " " * 53 + "â•‘")
        output.append("â• " + "â•" * 78 + "â•£")

        # Summary statistics
        summary = vulns['summary']
        total = summary['total']

        output.append(f"â•‘ ğŸ“Š SCAN RESULTS" + " " * 62 + "â•‘")
        output.append(f"â•‘ Total Vulnerabilities Found: {total}" + " " * (47 - len(str(total))) + "â•‘")
        output.append("â•‘" + " " * 78 + "â•‘")

        # Severity breakdown
        severity_bar = self._create_severity_bar(summary)
        output.append(f"â•‘ {severity_bar}" + " " * (77 - len(severity_bar)) + "â•‘")
        output.append("â•‘" + " " * 78 + "â•‘")
        output.append(
            f"â•‘ ğŸ”´ Critical: {summary['critical']:<5} ğŸŸ  High: {summary['high']:<5} ğŸŸ¡ Medium: {summary['medium']:<5}" + " " * 30 + "â•‘")
        output.append(f"â•‘ ğŸŸ¢ Low: {summary['low']:<5}      âšª Info: {summary['info']:<5}" + " " * 42 + "â•‘")

        # Services discovered
        if vulns['services']:
            output.append("â• " + "â•" * 78 + "â•£")
            output.append(f"â•‘ ğŸŒ SERVICES DISCOVERED" + " " * 55 + "â•‘")
            for service, count in list(vulns['services'].items())[:5]:
                output.append(
                    f"â•‘   â€¢ {service}: {count} instance(s)" + " " * (58 - len(service) - len(str(count))) + "â•‘")

        # CVEs found
        if vulns['cves']:
            output.append("â• " + "â•" * 78 + "â•£")
            output.append(
                f"â•‘ ğŸ“‹ CVEs DETECTED ({len(vulns['cves'])} total)" + " " * (55 - len(str(len(vulns['cves'])))) + "â•‘")
            for cve in vulns['cves'][:5]:
                output.append(f"â•‘   â€¢ {cve}" + " " * (71 - len(cve)) + "â•‘")
            if len(vulns['cves']) > 5:
                output.append(
                    f"â•‘   ... and {len(vulns['cves']) - 5} more" + " " * (64 - len(str(len(vulns['cves']) - 5))) + "â•‘")

        # Exploits available
        if vulns['exploits']:
            output.append("â• " + "â•" * 78 + "â•£")
            output.append(f"â•‘ âš ï¸  EXPLOITS AVAILABLE" + " " * 55 + "â•‘")
            for exploit in vulns['exploits'][:3]:
                output.append(f"â•‘   Port {exploit['port']}: {exploit['script'][:40]}" + " " * 20 + "â•‘")

        # Detailed vulnerabilities by host
        output.append("â• " + "â•" * 78 + "â•£")
        output.append(f"â•‘ ğŸ“ DETAILED FINDINGS" + " " * 57 + "â•‘")
        output.append("â•‘" + " " * 78 + "â•‘")

        for host in vulns['hosts']:
            if not host['vulnerabilities'] and not host['open_ports']:
                continue

            output.append(f"â•‘ ğŸ–¥ï¸  HOST: {host['address']}" + " " * (63 - len(host['address'])) + "â•‘")

            # Show open ports
            if host['open_ports']:
                ports_str = ','.join(map(str, host['open_ports'][:10]))
                output.append(f"â•‘    Open Ports: {ports_str}" + " " * (61 - len(ports_str)) + "â•‘")

            # Show services
            if host['services']:
                output.append(f"â•‘    Services:" + " " * 64 + "â•‘")
                for svc in host['services'][:5]:
                    svc_str = f"{svc['service']}:{svc['port']}"
                    if svc['version']:
                        svc_str += f" ({svc['product']} {svc['version']})"[:40]
                    output.append(f"â•‘      â€¢ {svc_str}" + " " * (68 - len(svc_str)) + "â•‘")

            # Group vulnerabilities by severity
            if host['vulnerabilities']:
                by_severity = defaultdict(list)
                for vuln in host['vulnerabilities']:
                    by_severity[vuln['severity']].append(vuln)

                output.append(f"â•‘    Vulnerabilities:" + " " * 57 + "â•‘")

                # Show critical and high priority
                for severity in ['critical', 'high', 'medium', 'low', 'info']:
                    if severity in by_severity:
                        for vuln in by_severity[severity][:2]:  # Limit to 2 per severity
                            severity_icon = {
                                'critical': 'ğŸ”´',
                                'high': 'ğŸŸ ',
                                'medium': 'ğŸŸ¡',
                                'low': 'ğŸŸ¢',
                                'info': 'âšª'
                            }[severity]

                            title = vuln['title'][:50]
                            output.append(f"â•‘      {severity_icon} [{severity.upper()[:4]}] {title}" + " " * (
                                    58 - len(severity) - len(title)) + "â•‘")

                            if vuln.get('cves'):
                                cve_str = ', '.join(vuln['cves'][:2])
                                output.append(f"â•‘         CVE: {cve_str[:50]}" + " " * (62 - len(cve_str[:50])) + "â•‘")

                            if vuln['remediation']:
                                rem_str = vuln['remediation'][:55]
                                output.append(f"â•‘         Fix: {rem_str}" + " " * (62 - len(rem_str)) + "â•‘")

            output.append("â•‘" + " " * 78 + "â•‘")

        # Footer
        output.append("â•š" + "â•" * 78 + "â•")

        return "\n".join(output)

    def _create_severity_bar(self, summary: dict) -> str:
        """Create a visual severity distribution bar"""
        total = summary['total']
        if total == 0:
            return "No vulnerabilities found"

        bar_width = 40
        critical_width = int((summary['critical'] / total) * bar_width)
        high_width = int((summary['high'] / total) * bar_width)
        medium_width = int((summary['medium'] / total) * bar_width)
        low_width = int((summary['low'] / total) * bar_width)
        info_width = bar_width - critical_width - high_width - medium_width - low_width

        bar = ""
        bar += "â–ˆ" * critical_width if critical_width > 0 else ""
        bar += "â–“" * high_width if high_width > 0 else ""
        bar += "â–’" * medium_width if medium_width > 0 else ""
        bar += "â–‘" * low_width if low_width > 0 else ""
        bar += "Â·" * info_width if info_width > 0 else ""

        return f"[{bar:<{bar_width}}]"

    def _assess_risk(self, vulns: dict) -> str:
        """Assess overall risk level with detailed explanation"""
        summary = vulns['summary']

        if summary['critical'] > 0:
            return f"ğŸ”´ **CRITICAL RISK** - {summary['critical']} critical vulnerabilities require immediate action!"
        elif summary['high'] > 2:
            return f"ğŸŸ  **HIGH RISK** - {summary['high']} high-severity vulnerabilities detected. Urgent remediation needed."
        elif summary['high'] > 0 or summary['medium'] > 5:
            return f"ğŸŸ¡ **MEDIUM RISK** - Several vulnerabilities found. Plan remediation activities."
        elif summary['medium'] > 0 or summary['low'] > 10:
            return f"ğŸŸ¢ **LOW RISK** - Minor vulnerabilities detected. Schedule updates during maintenance."
        elif summary['total'] > 0:
            return f"âšª **MINIMAL RISK** - Only informational findings. Good security posture."
        else:
            return f"âœ… **NO VULNERABILITIES DETECTED** - No issues found with current scan configuration."

    def _invoke(self, tool_parameters: dict[str, Any]) -> Generator[ToolInvokeMessage, None, None]:
        """Execute comprehensive vulnerability scan"""
        try:
            params = VulnerabilityScannerParameters(**tool_parameters)

            # Import python-nmap
            try:
                import nmap
            except ImportError:
                yield self.create_text_message("âŒ Error: python-nmap library not installed")
                return

            nm = nmap.PortScanner()

            # Initial status
            yield self.create_text_message(
                f"ğŸ›¡ï¸ **Vulnerability Scanner v2.0**\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"ğŸ¯ Target: {params.target}\n"
                f"ğŸ“‹ Strategy: {params.scan_strategy.upper()}\n"
                f"ğŸ” Categories: {', '.join(params.vuln_categories)}\n"
                f"âš¡ Performance: {params.parallel_scripts} parallel scripts\n"
            )

            # Build scan arguments
            arguments, scripts_to_run = self._build_scan_arguments(params)

            # Log the scan command
            logger.info(f"Executing: nmap {arguments} {params.target}")

            # Show scripts being executed
            if scripts_to_run:
                yield self.create_text_message(
                    f"ğŸ“ Executing {len(scripts_to_run)} vulnerability detection scripts...\n"
                    f"This may take a few minutes depending on the target and network conditions.\n"
                )

            # Execute the scan
            start_time = time.time()
            try:
                scan_result = nm.scan(hosts=params.target, arguments=arguments)
            except Exception as e:
                yield self.create_text_message(f"âŒ Scan error: {e}")
                logger.error(f"Scan failed: {e}", exc_info=True)
                return

            duration = time.time() - start_time

            # Parse results
            vulns = self._parse_vulnerabilities(nm, scan_result, scripts_to_run)

            # Generate and send report
            report = self._format_report(vulns, params)
            yield self.create_text_message(report)

            # Send JSON data for further processing
            yield self.create_json_message(vulns)

            # Risk assessment and recommendations
            risk_assessment = self._assess_risk(vulns)

            # Final summary with actionable insights
            yield self.create_text_message(
                f"\n{risk_assessment}\n"
                f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                f"â±ï¸ Scan Duration: {duration:.2f} seconds\n"
                f"ğŸ“Š Vulnerabilities: {vulns['summary']['total']}\n"
                f"ğŸ” CVEs Found: {len(vulns['cves'])}\n"
                f"âš ï¸ Exploits Available: {len(vulns['exploits'])}\n"
            )

            # Provide top recommendations if vulnerabilities found
            if vulns['summary']['total'] > 0:
                yield self.create_text_message(
                    "\nğŸ“Œ **TOP RECOMMENDATIONS:**\n"
                    "1. Address critical and high severity issues immediately\n"
                    "2. Apply vendor security patches for identified CVEs\n"
                    "3. Review service configurations for security hardening\n"
                    "4. Consider implementing additional security controls\n"
                    "5. Schedule regular vulnerability assessments\n"
                )

        except Exception as e:
            logger.error(f"Vulnerability scanner error: {e}", exc_info=True)
            yield self.create_text_message(f"âŒ Critical error: {e}")
