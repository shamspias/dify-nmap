import logging
from collections.abc import Generator
from typing import Any, List, Dict, Optional
import re

from dify_plugin import Tool
from dify_plugin.entities.tool import ToolInvokeMessage
from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


class VulnerabilityScannerParameters(BaseModel):
    """Parameters matching the YAML configuration"""

    target: str = Field(
        ...,
        description="Target to scan (IP, hostname, CIDR, or range)"
    )

    scan_level: str = Field(
        "safe",
        description="Scan level: safe, default, intrusive, aggressive"
    )

    vulnerability_types: str = Field(
        "common",
        description="Vulnerability types: common, web, database, network, all"
    )

    port_range: str = Field(
        "common",
        description="Port range: common, top100, top1000, all"
    )

    check_cves: bool = Field(
        True,
        description="Check for known CVEs"
    )

    check_default_creds: bool = Field(
        True,
        description="Check for default credentials"
    )

    check_ssl_issues: bool = Field(
        True,
        description="Check for SSL/TLS issues"
    )


class VulnerabilityScannerTool(Tool):
    """Fixed vulnerability scanner tool"""

    # Corrected NSE script names
    VULNERABILITY_SCRIPTS = {
        "common": [
            "vulners",
            "vuln",
            "default"
        ],
        "web": [
            "http-vuln-cve2017-5638",  # Apache Struts
            "http-vuln-cve2014-3704",  # Drupal
            "http-sql-injection",
            "http-stored-xss",
            "http-csrf",
            "http-shellshock",
            "http-slowloris-check",
            "http-enum",
            "http-methods",
            "http-default-accounts"
        ],
        "ssl": [
            "ssl-heartbleed",
            "ssl-poodle",
            "ssl-ccs-injection",
            "ssl-cert",
            "ssl-enum-ciphers",
            "sslv2",
            "ssl-dh-params"
        ],
        "smb": [
            "smb-vuln-ms17-010",  # EternalBlue
            "smb-vuln-ms08-067",  # Conficker
            "smb-vuln-conficker",
            "smb-vuln-cve2009-3103",
            "smb-vuln-ms06-025",
            "smb-vuln-ms07-029",
            "smb-os-discovery",
            "smb-security-mode"
        ],
        "database": [
            "mysql-vuln-cve2012-2122",
            "mysql-empty-password",
            "ms-sql-empty-password",
            "mongodb-databases",
            "redis-info"
        ],
        "network": [
            "ftp-anon",
            "ftp-vsftpd-backdoor",
            "smtp-open-relay",
            "snmp-brute",
            "telnet-encryption",
            "vnc-brute"
        ],
        "default_creds": [
            "http-default-accounts",
            "ftp-anon",
            "mysql-empty-password",
            "ms-sql-empty-password",
            "telnet-brute"
        ]
    }

    # Port mappings
    PORT_MAPPINGS = {
        "common": "21,22,23,25,53,80,110,139,143,443,445,993,995,1433,3306,3389,8080,8443",
        "top100": "--top-ports 100",
        "top1000": "--top-ports 1000",
        "all": "-p-"
    }

    def _build_scan_arguments(self, params: VulnerabilityScannerParameters) -> tuple[str, List[str]]:
        """Build Nmap arguments based on parameters"""
        args = []
        scripts_to_run = []

        # Port specification
        if params.port_range in self.PORT_MAPPINGS:
            port_arg = self.PORT_MAPPINGS[params.port_range]
            if "--top-ports" in port_arg:
                args.append(port_arg)
            else:
                args.append(f"-p {port_arg}")
        else:
            args.append(f"-p {params.port_range}")

        # Service detection (needed for vulnerability scripts)
        args.append("-sV")

        # Determine scripts based on vulnerability types
        if params.vulnerability_types == "all":
            # Use all categories
            for category, scripts in self.VULNERABILITY_SCRIPTS.items():
                if category != "default_creds" or params.check_default_creds:
                    scripts_to_run.extend(scripts)
        elif params.vulnerability_types in self.VULNERABILITY_SCRIPTS:
            scripts_to_run.extend(self.VULNERABILITY_SCRIPTS[params.vulnerability_types])
        else:
            # Default to common
            scripts_to_run.extend(self.VULNERABILITY_SCRIPTS["common"])

        # Add SSL scripts if requested
        if params.check_ssl_issues and params.vulnerability_types != "all":
            scripts_to_run.extend(self.VULNERABILITY_SCRIPTS["ssl"])

        # Add default credential scripts if requested
        if params.check_default_creds and params.vulnerability_types != "all":
            scripts_to_run.extend(self.VULNERABILITY_SCRIPTS["default_creds"])

        # Add CVE detection if requested
        if params.check_cves:
            scripts_to_run.append("vulners")

        # Remove duplicates
        scripts_to_run = list(set(scripts_to_run))

        # Set scan aggressiveness based on level
        if params.scan_level == "safe":
            args.append("-T2")
            # Filter out intrusive scripts
            intrusive = ["brute", "dos", "exploit", "fuzzer"]
            scripts_to_run = [s for s in scripts_to_run if not any(i in s for i in intrusive)]
        elif params.scan_level == "default":
            args.append("-T3")
        elif params.scan_level == "intrusive":
            args.append("-T4")
            scripts_to_run.append("intrusive")
        elif params.scan_level == "aggressive":
            args.append("-T4")
            scripts_to_run.extend(["intrusive", "exploit"])

        # Add scripts to command
        if scripts_to_run:
            script_string = ",".join(scripts_to_run)
            args.append(f"--script={script_string}")

        # Additional settings
        args.append("-Pn")  # Skip ping
        args.append("--script-timeout 60s")
        args.append("--max-retries 2")
        args.append("-v")  # Verbose for better output

        return " ".join(args), scripts_to_run

    def _parse_vulnerabilities(self, nm, scripts_run: List[str]) -> dict:
        """Parse vulnerability findings from scan results"""
        vulns = {
            "summary": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "info": 0,
                "total": 0
            },
            "hosts": [],
            "cves": [],
            "services": {},
            "scripts_executed": scripts_run
        }

        for host in nm.all_hosts():
            if nm[host].state() != "up":
                continue

            host_vulns = {
                "address": host,
                "hostname": nm[host].hostname() if nm[host].hostname() else host,
                "vulnerabilities": [],
                "open_ports": []
            }

            # Check each port
            for proto in nm[host].all_protocols():
                for port in nm[host][proto].keys():
                    port_info = nm[host][proto][port]

                    if port_info['state'] == 'open':
                        host_vulns['open_ports'].append(port)

                        # Track services
                        service_name = port_info.get('name', 'unknown')
                        if service_name not in vulns['services']:
                            vulns['services'][service_name] = 0
                        vulns['services'][service_name] += 1

                        # Check for script results
                        if 'script' in port_info:
                            for script_name, script_output in port_info['script'].items():
                                vuln_info = self._extract_vulnerability_info(
                                    script_name, script_output, port, service_name
                                )
                                if vuln_info:
                                    host_vulns['vulnerabilities'].append(vuln_info)
                                    vulns['summary'][vuln_info['severity']] += 1
                                    vulns['summary']['total'] += 1

                                    # Extract CVEs
                                    cves = re.findall(r'CVE-\d{4}-\d+', script_output, re.IGNORECASE)
                                    if cves:
                                        vulns['cves'].extend(cves)

            # Check host-level scripts
            if 'hostscript' in nm[host]:
                for script in nm[host]['hostscript']:
                    vuln_info = self._extract_vulnerability_info(
                        script['id'], script.get('output', ''), 'host', 'host'
                    )
                    if vuln_info:
                        host_vulns['vulnerabilities'].append(vuln_info)
                        vulns['summary'][vuln_info['severity']] += 1
                        vulns['summary']['total'] += 1

            if host_vulns['vulnerabilities'] or host_vulns['open_ports']:
                vulns['hosts'].append(host_vulns)

        # Remove duplicate CVEs
        vulns['cves'] = list(set(vulns['cves']))

        return vulns

    def _extract_vulnerability_info(self, script_name: str, output: str, port: Any, service: str) -> Optional[Dict]:
        """Extract vulnerability information from script output"""

        # Check if this is actually a vulnerability
        vuln_keywords = ['vuln', 'cve', 'vulnerable', 'risk', 'exploit', 'attack', 'disclosure']
        if not any(kw in script_name.lower() or kw in output.lower() for kw in vuln_keywords):
            return None

        severity = self._determine_severity(script_name, output)

        return {
            "port": port,
            "service": service,
            "script": script_name,
            "severity": severity,
            "description": output[:300] if output else "Vulnerability detected"
        }

    def _determine_severity(self, script_name: str, output: str) -> str:
        """Determine vulnerability severity"""
        output_lower = output.lower() if output else ""
        script_lower = script_name.lower()

        # Critical patterns
        if any(pattern in script_lower or pattern in output_lower for pattern in
               ['critical', 'heartbleed', 'shellshock', 'ms17-010', 'eternalblue']):
            return 'critical'

        # High patterns
        if any(pattern in script_lower or pattern in output_lower for pattern in
               ['high', 'sql injection', 'empty password', 'default credentials']):
            return 'high'

        # Medium patterns
        if any(pattern in script_lower or pattern in output_lower for pattern in
               ['medium', 'xss', 'csrf', 'weak']):
            return 'medium'

        # Low patterns
        if any(pattern in script_lower or pattern in output_lower for pattern in
               ['low', 'informational', 'verbose']):
            return 'low'

        return 'info'

    def _invoke(self, tool_parameters: dict[str, Any]) -> Generator[ToolInvokeMessage, None, None]:
        """Execute vulnerability scan"""
        try:
            params = VulnerabilityScannerParameters(**tool_parameters)

            # Import python-nmap
            try:
                import nmap
            except ImportError:
                yield self.create_text_message("‚ùå Error: python-nmap library not installed")
                return

            nm = nmap.PortScanner()

            # Initial status
            yield self.create_text_message(
                f"üõ°Ô∏è Starting Vulnerability Scan\n"
                f"Target: {params.target}\n"
                f"Scan Level: {params.scan_level}\n"
                f"Focus: {params.vulnerability_types}\n"
            )

            # Build scan arguments
            arguments, scripts_to_run = self._build_scan_arguments(params)

            logger.info(f"Executing: nmap {arguments} {params.target}")

            # Execute scan
            try:
                scan_result = nm.scan(hosts=params.target, arguments=arguments)
            except Exception as e:
                yield self.create_text_message(f"‚ùå Scan error: {e}")
                return

            # Parse results
            vulns = self._parse_vulnerabilities(nm, scripts_to_run)

            # Create output
            output = []
            output.append("=" * 60)
            output.append("VULNERABILITY SCAN RESULTS")
            output.append("=" * 60)
            output.append(f"Target: {params.target}")
            output.append(f"Total Vulnerabilities: {vulns['summary']['total']}")
            output.append("")

            if vulns['summary']['total'] > 0:
                output.append("SEVERITY BREAKDOWN:")
                output.append(f"  üî¥ Critical: {vulns['summary']['critical']}")
                output.append(f"  üü† High: {vulns['summary']['high']}")
                output.append(f"  üü° Medium: {vulns['summary']['medium']}")
                output.append(f"  üü¢ Low: {vulns['summary']['low']}")
                output.append(f"  ‚ö™ Info: {vulns['summary']['info']}")
                output.append("")

            # Show findings by host
            for host in vulns['hosts']:
                output.append(f"\nHost: {host['address']}")
                output.append(f"Open Ports: {', '.join(map(str, host['open_ports'][:10]))}")

                if host['vulnerabilities']:
                    output.append("Vulnerabilities Found:")
                    for vuln in host['vulnerabilities'][:5]:
                        severity_icon = {
                            'critical': 'üî¥',
                            'high': 'üü†',
                            'medium': 'üü°',
                            'low': 'üü¢',
                            'info': '‚ö™'
                        }.get(vuln['severity'], '‚ö™')

                        output.append(f"  {severity_icon} [{vuln['severity'].upper()}] Port {vuln['port']}")
                        output.append(f"    Script: {vuln['script']}")
                        output.append(f"    {vuln['description'][:100]}...")

            # CVEs found
            if vulns['cves']:
                output.append(f"\nCVEs Detected: {', '.join(vulns['cves'][:5])}")
                if len(vulns['cves']) > 5:
                    output.append(f"  ... and {len(vulns['cves']) - 5} more")

            yield self.create_text_message("\n".join(output))

            # Send JSON data
            yield self.create_json_message(vulns)

            # Risk assessment
            if vulns['summary']['critical'] > 0:
                risk = "üî¥ CRITICAL RISK"
            elif vulns['summary']['high'] > 0:
                risk = "üü† HIGH RISK"
            elif vulns['summary']['medium'] > 0:
                risk = "üü° MEDIUM RISK"
            elif vulns['summary']['low'] > 0:
                risk = "üü¢ LOW RISK"
            else:
                risk = "‚úÖ NO VULNERABILITIES FOUND"

            yield self.create_text_message(
                f"\n{risk}\n"
                f"Scan completed successfully!"
            )

        except Exception as e:
            logger.error(f"Vulnerability scanner error: {e}", exc_info=True)
            yield self.create_text_message(f"‚ùå Error: {e}")
